---
title: "[Algorithm] 프로그래머스 선입 선출 스케줄링"
excerpt: "연습문제 선입 선출 스케줄링"
category :
  - Algorithm
tag :
  - Algorithm
  - BinarySearch
toc : true
toc_sticky: true
comments: true
---

# 프로그래머스: 선입 선출 스케줄링

## 문제 링크
[선입 선출 스케줄링](https://school.programmers.co.kr/learn/courses/30/lessons/12920)

## 풀이
문제를 보고 우선순위 큐를 활용하면 시간복잡도를 n log n 으로 끝낼 수 있어서 풀었으나 몇개의 효율성 테스트를 통과를 못하였다.
하지만 스터디원에게 물어보니 heapq를 사용하면 아마 몇개 통과못해서 이진탐색을 사용하라고 피드백을 받았다.
그럼에도 불구하고 스터디원의 답을 봤을때 단순 시간복잡도 계산으로 동일한거 같아 어떤부분이 문제인지 장난삼아 ChatGPT에게 물어봤는데
놀라운 답변을 받았다.....

### 우선순위 큐 코드설명
일단 core당 연산이 끝나는 시간을 맨앞으로 넣으면 다음으로 일해야할 코어가 나온다.
그 다음으로는 문제 조건과 같이 인덱스가 빠른 순위로 넣어야함으로 인덱스를 넣었고 
큐에 넣었을때 몇번에 iteration을 돌았는지 연산과정을 스킵하기 위해 넣어줬다. (메모리를 늘리고 연산효율을 높임)
remain work 변수는 왜그런가하면 **일이 0초일때는 모든 코어에서 동작** 함으로 시작시 코어 개수만큼 빼주고 시작한다.
하나씩 우선순위 큐에서 합하고 남은일을 해나가면서 처리하였다.

이진탐색 풀이는 ChatGPT의 자세한 해설을 참고하시길 바랍니다.
(소름이 돋을정도로 두 코드의 차이를 자세하게 알려줍니다.)


## Code
### 우선순위 큐 (효율성 2456 통과 x)
```python
import heapq

def solution(n, cores):
    schedule = [] 
    for i, c in enumerate(cores):
        heapq.heappush(schedule, [c, i, 1])
        
    remain_work = n - len(cores)
    while remain_work > 0:
        c, idx, it = heapq.heappop(schedule)
        remain_work -= 1
        it += 1
        heapq.heappush(schedule, [cores[idx] * it, idx, it])
    return (idx + 1)
```
#### 시간복잡도
- 정확성 테스트
>   테스트 1 〉	통과 (0.82ms, 10.2MB)
>   테스트 2 〉	통과 (2.17ms, 10.2MB)
>   테스트 3 〉	통과 (1.76ms, 10.3MB)
>   테스트 4 〉	통과 (3.13ms, 10.3MB)
>   테스트 5 〉	통과 (2.62ms, 10.7MB)
>   테스트 6 〉	통과 (1.77ms, 10.3MB)
>   테스트 7 〉	통과 (0.76ms, 10.4MB)
>   테스트 8 〉	통과 (2.34ms, 10.6MB)
>   테스트 9 〉	통과 (0.05ms, 10.3MB)
>   테스트 10 〉	통과 (0.03ms, 10.3MB)
>   테스트 11 〉	통과 (0.03ms, 10.3MB)
>   테스트 12 〉	통과 (2.32ms, 10.6MB)
>   테스트 13 〉	통과 (0.98ms, 10.4MB)
>   테스트 14 〉	통과 (2.51ms, 10.2MB)
- 효율성  테스트
>   테스트 1 〉	통과 (19.46ms, 11.6MB)
>   테스트 2 〉	실패 (시간 초과)
>   테스트 3 〉	통과 (9.27ms, 10.9MB)
>   테스트 4 〉	실패 (시간 초과)
>   테스트 5 〉	실패 (시간 초과)
>   테스트 6 〉	실패 (시간 초과)

### 이진탐색(Chat GPT 답)
```python
def solution(n, cores):
    if n <= len(cores):
        return n

    left, right = 0, max(cores) * n

    while left < right:
        mid = (left + right) // 2
        completed = sum(mid // core for core in cores)
        
        if completed >= n - len(cores):
            right = mid
        else:
            left = mid + 1

    time = left
    remaining_work = n - len(cores) - sum((time - 1) // core for core in cores)

    for i, core in enumerate(cores):
        if time % core == 0:
            remaining_work -= 1
            if remaining_work == 0:
                return i + 1
```
#### 시간복잡도
- 정확성 테스트
>   테스트 1 〉	통과 (0.45ms, 10.3MB)
>   테스트 2 〉	통과 (0.87ms, 10.2MB)
>   테스트 3 〉	통과 (0.36ms, 10.2MB)
>   테스트 4 〉	통과 (0.82ms, 10.3MB)
>   테스트 5 〉	통과 (4.73ms, 10.3MB)
>   테스트 6 〉	통과 (2.18ms, 10.2MB)
>   테스트 7 〉	통과 (0.85ms, 10.1MB)
>   테스트 8 〉	통과 (3.00ms, 10.4MB)
>   테스트 9 〉	통과 (0.26ms, 10.3MB)
>   테스트 10 〉	통과 (0.02ms, 10.2MB)
>   테스트 11 〉	통과 (0.02ms, 10.2MB)
>   테스트 12 〉	통과 (4.44ms, 10.2MB)
>   테스트 13 〉	통과 (1.54ms, 10.3MB)
>   테스트 14 〉	통과 (0.77ms, 10.1MB)
- 효율성  테스트
>   테스트 1 〉	통과 (22.84ms, 10.4MB)
>   테스트 2 〉	통과 (11.78ms, 10.3MB)
>   테스트 3 〉	통과 (16.58ms, 10.1MB)
>   테스트 4 〉	통과 (10.05ms, 10.3MB)
>   테스트 5 〉	통과 (4.97ms, 10.1MB)
>   테스트 6 〉	통과 (5.38ms, 10.3MB)

## ChatGPT 풀이
### Q. 내코드를 더 최적화 시켜줄 수 있어?

코드를 최적화하는 방법은 여러 가지가 있지만, 주어진 코드에서 수행 시간과 메모리 사용량을 줄이기 위해 몇 가지 변경 사항을 제안할 수 있습니다. 현재 코드의 주된 병목 현상은 **`heapq`** 모듈을 사용하는 부분입니다. 이를 개선하기 위해 몇 가지 변경 사항을 적용할 수 있습니다.

#### **개선된 코드**

1. **최적화된 접근 방식**: 전체 작업을 미리 계산하고, 각 작업이 할당되는 시간을 계산하여 마지막 작업을 수행하는 코어를 결정합니다.
2. **필요 없는 변수 제거**: **`it`** 변수를 제거하여 불필요한 계산을 줄입니다.

이 방법은 **`heapq`**을 사용하지 않으며, 주어진 코어의 작업 주기를 기반으로 수학적으로 접근하여 마지막 작업을 할당하는 코어를 계산합니다.

#### **설명**

1. **초기 조건 처리**: **`n`**이 **`cores`**의 길이보다 작거나 같을 경우, 바로 해당 코어를 반환합니다.
2. **이진 탐색**: 작업이 완료되는 시간을 이진 탐색으로 찾아서 해당 시간 내에 작업을 완료할 수 있는 최소 시간을 계산합니다.
3. **총 완료 작업 계산**: **`mid`** 시간 내에 모든 코어가 수행할 수 있는 작업의 합을 계산합니다.
4. **시간 결정**: 이진 탐색을 통해 작업 완료 시간을 결정합니다.
5. **남은 작업 계산**: 결정된 시간 이전의 작업을 통해 남은 작업의 수를 계산합니다.
6. **마지막 작업 할당 코어 찾기**: 마지막 작업을 수행할 코어를 결정합니다.

이 방법을 통해 불필요한 연산을 줄이고, 효율적으로 마지막 작업을 할당할 코어를 찾을 수 있습니다.

### Q. 시간복잡도로만 보면 두코드가 n log n으로 같아보이는데 어디에서 큰차이가 나는걸까?
두 코드 모두 시간복잡도 관점에서 𝑂(𝑛log⁡𝑛)
*O*(*n* log *n*)로 보일 수 있지만, 실제 실행 시간에는 큰 차이가 날 수 있습니다. 그 차이를 자세히 분석해보겠습니다.

#### **시간복잡도 분석 (내 코드)**

1. **초기화**:
    - **`heapq.heappush`** 호출 *O*(*m*log*m*), 여기서 *m*은 **`cores`**의 길이
        
        𝑂(𝑚log⁡𝑚)
        
        𝑚
        
2. **작업 분배 루프**:
    - 각 루프당 **`heapq.heappop`** *O*(log*m*)
        
        𝑂(log⁡𝑚)
        
    - 각 루프당 **`heapq.heappush`** *O*(log*m*)
        
        𝑂(log⁡𝑚)
        
    - 총 *n*−*m*번의 반복 (*n*은 작업 수, *m*은 코어 수)
        
        𝑛−𝑚
        
        𝑛
        
        𝑚
        
    - 따라서 루프의 총 시간복잡도는 *O*((*n*−*m*)log*m*)
        
        𝑂((𝑛−𝑚)log⁡𝑚)
        

#### **시간복잡도 분석 (개선 코드)**

1. **이진 탐색**:
    - 탐색 범위는 **`0`**에서 **`max(cores) * n`**까지
    - 이진 탐색의 반복 횟수는 *O*(log(*max*(*cores*)∗*n*)), 일반적으로 *O*(log*n*)로 간주
        
        𝑂(log⁡(𝑚𝑎𝑥(𝑐𝑜𝑟𝑒𝑠)∗𝑛))
        
        𝑂(log⁡𝑛)
        
2. **완료된 작업 계산**:
    - 각 이진 탐색 단계마다 **`sum(mid // core for core in cores)`**의 시간복잡도는 *O*(*m*), 여기서 *m*은 **`cores`**의 길이
        
        𝑂(𝑚)
        
        𝑚
        
3. **이진 탐색의 총 복잡도**:
    - 각 단계에서 *O*(*m*) 계산을 동반하는 *O*(log*n*) 단계이므로 전체 시간복잡도는 *O*(*m*log*n*)
        
        𝑂(𝑚)
        
        𝑂(log⁡𝑛)
        
        𝑂(𝑚log⁡𝑛)
        

#### **실제 차이점**

1. **상수 계수의 차이**:
    - 원래 코드는 루프 내에서 **`heapq.heappop`**과 **`heapq.heappush`**를 반복적으로 호출하여 각 작업에 대해 힙 연산을 수행합니다. 이는 높은 상수 계수를 가지는 연산입니다.
    - 개선된 코드는 이진 탐색과 단순한 반복문을 사용하므로, 상대적으로 힙 연산보다 상수 계수가 작습니다.
2. **힙 연산의 빈도**:
    - 원래 코드는 **`n - m`**번의 힙 연산을 포함하여 더 많은 연산을 수행합니다.
    - 개선된 코드는 이진 탐색과 몇 번의 단순 반복문만 사용합니다.
3. **메모리 접근 패턴**:
    - 개선된 코드는 메모리를 더 효율적으로 접근하여 캐시 히트 비율이 더 높아질 수 있습니다.
    - 힙 연산은 메모리 접근이 불규칙하게 발생하여 캐시 미스를 유발할 가능성이 높습니다.

따라서, 시간복잡도는 둘 다 𝑂(𝑛log⁡𝑛)*O*(*n*log*n*)로 보일 수 있지만, 실제로는 상수 계수와 연산 빈도의 차이로 인해 개선된 코드가 훨씬 더 빠르게 동작할 수 있습니다.

## 후기
등대와 같이 어려운 문제를 풀다가 힐링 할 수 있는 문제였다.

### priority queue & heapq 비교
속도: heapq > priority queue
안정성: heapq < priority queue

#### 참고 블로그 
[https://velog.io/@hovelopin/힙큐-heapq](https://velog.io/@hovelopin/%ED%9E%99%ED%81%90-heapq)